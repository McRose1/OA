package 字节跳动;

/*  毕业旅行问题（这题也太难了，看了答案也只是看个半懂）
    小明目前在做一份毕业旅行的规划。打算从北京出发，分别去若干个城市，然后再回到北京，每个城市之间均乘坐高铁，且每个城市只去一次。
    由于经费有限，希望能够通过合理的路线安排尽可能的省一些路上的花销。给定一组城市和每对城市之间的火车票的价钱，找到每个城市只访问一次并返回起点的最小车费花销。

    输入描述：
    城市个数n（1<n≤20，包括北京）
    城市间的车票价钱 n行n列的矩阵 m[n][n]

    输出描述：
    最小车费花销 s

    输入例子：
    4
    0 2 6 5
    2 0 4 4
    6 4 0 2
    5 4 2 0

    输出例子：
    13

    例子说明：
    共 4 个城市，城市 1 和城市 1 的车费为0，城市 1 和城市 2 之间的车费为 2，城市 1 和城市 3 之间的车费为 6，城市 1 和城市 4 之间的车费为 5，依次类推。
    假设任意两个城市之间均有单程票可购买，且票价在1000元以内，无需考虑极端情况。
 */

import java.util.Scanner;
/*  旅行商问题（二维 DP）
    经过的路线是一条经过所有城市的闭合回路, 因此从哪一点出发是无所谓的, 因此不妨设从城市0出发
    d(i，V) 表示从i点经过点集Ｖ各点一次之后回到出发点的最短距离
    d(i，V') ＝ min {Cik+d(k,V－{k})}  (k∈V')
    d(k，{ }) ＝ Cik (k≠i)
    V = 2^(N - 1)
    假设从城市0出发，经城市1、2、3然后回到城市0的最短路径长度是：
    d(0, {1, 2, 3}) = min{dist(0->1) + d(1, { 2, 3}), dist(0->2) + d(2, {1, 3}), dist(0->3) + d(3, {1, 2})}
    继续推导：
    d(1, {2, 3}) = min{dist(1->2) + d(2, {3}), dist(1->3) + d(3, {2})}
    d(2, {1, 3}) = min{dist(2->1) + d(1, {3}), dist(2->3) + d(3, {1})}
    d(3, {1, 2}) = min{dist(3->1) + d(1, {2}), dist(3->2) + d(2, {1})}
    再继续化解为更小的子问题：
    d(1, {2}) = dist(1->2) + d(2, {})
    d(2, {3}) = dist(2->3) + d(3, {})
    d(3, {2}) = dist(3->2) + d(2, {})
    d(1, {3}) = dist(1->3) + d(3, {})
    d(2, {1}) = dist(2->1) + d(1, {})
    d(3, {1}) = dist(3->1) + d(1, {})
        {}  {001}  {010}  {011}  {100}  {101}  {110}  {111}
    0                                                  res
    1   2
    2   6
    3   5
 */
public class 毕业旅行问题 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[][] dist = new int[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                dist[i][j] = sc.nextInt();
            }
        }
        // 通过二进制表示不同的城市集合状态
        int V = 1 << (n - 1);
        int[][] dp = new int[n][V];
        // 设定起点城市为 0 号城市
        for (int i = 0; i < n; i++) {
            dp[i][0] = dist[i][0];
        }
        // 遍历所有城市集合，V[j]即为压缩状态的城市集合
        // 从 1到V-1 用二进制表示的话，刚好可以映射成除了0号城市外的剩余n-1个城市在不在子集V[j]，1代表在，0代表不在
        // 如 j=7:111，即 3，2，1 号城市均在集合中，j=5=101，即 3 号 和 1 号城市在集合中
        for (int j = 1; j < V; j++) {
            // 选定一个起点城市
            for (int i = 0; i < n; i++) {
                dp[i][j] = Integer.MAX_VALUE;
                // j>>(i-1) 从集合中取出第 i 号城市，和 1 求余如果等于 0，说明从 i 号城市出发，经过城市子集 V[j]，回到起点 0 号城市
                if (((j >> (i - 1)) & 1) == 0) {    // j >> -1 ==> j >> (-1+32) = 0
                    // 这里要求经过子集V[j]里的城市回到0号城市的最小距离
                    for (int k = 1; k < n; k++) {
                        // 遍历城市子集V[j]
                        if (((j >> (k - 1)) & 1) == 1) {
                            // 设s=j ^ (1 << (k - 1))
                            // 那么V[s]中肯定不包含k了，那么在j中把第k个城市置0就可以了，而j ^ (1 << (k - 1))的功能就是这个
                            dp[i][j] = Math.min(dp[i][j], dist[i][k] + dp[k][j ^ (1 << (k - 1))]);
                            // 还有怎么保证dp[k][j ^ (1 << (k - 1))]的值已经得到了呢，
                            // 注意所有的计算都是以dp表为准，从左往右从上往下的计算的，每次计算都用到左边列的数据
                        }
                    }
                }
            }
        }
        System.out.println(dp[0][V - 1]);
    }
}
